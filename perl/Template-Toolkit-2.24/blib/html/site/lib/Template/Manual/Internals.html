<?xml version="1.0" ?>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<!-- saved from url=(0017)http://localhost/ -->
<script language="JavaScript" src="../../../../displayToc.js"></script>
<script language="JavaScript" src="../../../../tocParas.js"></script>
<script language="JavaScript" src="../../../../tocTab.js"></script>
<link rel="stylesheet" type="text/css" href="../../../../scineplex.css">
<title>Template::Manual::Internals - Template Toolkit internals</title>
<link rel="stylesheet" href="../../../../Active.css" type="text/css" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:" />
</head>

<body>


<!-- INDEX BEGIN -->
<div name="index">
<script>writelinks('__top__',4);</script>
<h1><a>Template::Manual::Internals - Template Toolkit internals</a></h1>
<p><a name="__index__"></a></p>


<ul>

	<li><a href="#name">NAME</a></li>
	<li><a href="#introduction">Introduction</a></li>
	<li><a href="#outside_looking_in">Outside Looking In</a></li>
	<li><a href="#inside_looking_out">Inside Looking Out</a></li>
	<li><a href="#hacking_on_the_template_toolkit">Hacking on the Template Toolkit</a></li>
</ul>

<hr name="index" />
</div>
<!-- INDEX END -->

<p>
</p>
<h1><a name="name">NAME</a></h1>
<p>Template::Manual::Internals - Template Toolkit internals</p>
<p>
</p>
<hr />
<h1><a name="introduction">Introduction</a></h1>
<p>This section of the documentation is aimed at developers wishing to 
know more about how the Template Toolkit works on the inside in order
to extend or adapt it to their own needs.</p>
<p>If that doesn't sound like you then you probably don't need to read this.
There is no test afterwards.</p>
<p>
</p>
<hr />
<h1><a name="outside_looking_in">Outside Looking In</a></h1>
<p>The <a href="../../../..//Develop/Perl/Template-Toolkit-2.24/blib/html/site/lib/Template.html">the Template manpage</a> module is simply a front end module which creates and
uses a <a href="../../../..//Develop/Perl/Template-Toolkit-2.24/blib/html/site/lib/Template/Service.html">the Template::Service manpage</a> and pipes the output wherever you want it to
go (<code>STDOUT</code> by default, or maybe a file, scalar, etc).  The
<code>Apache::Template</code> module (available separately from CPAN) is another
front end.  That creates a <code>Template::Service::Apache</code> object, calls on
it as required and sends the output back to the relevant
<code>Apache::Request</code> object.</p>
<p>These front-end modules are really only there to handle any specifics
of the environment in which they're being used.  The <code>Apache::Template</code>
front end, for example, handles <code>Apache::Request</code> specifics and
configuration via the <em class="file">httpd.conf</em>.  The regular <a href="../../../..//Develop/Perl/Template-Toolkit-2.24/blib/html/site/lib/Template.html">the Template manpage</a> front-end
deals with <code>STDOUT</code>, variable refs, etc.  Otherwise it is
<a href="../../../..//Develop/Perl/Template-Toolkit-2.24/blib/html/site/lib/Template/Service.html">the Template::Service manpage</a> (or subclass) which does all the work.</p>
<p>The <a href="../../../..//Develop/Perl/Template-Toolkit-2.24/blib/html/site/lib/Template/Service.html">the Template::Service manpage</a> module provides a high-quality template
delivery service, with bells, whistles, signed up service level
agreement and a 30-day no quibble money back guarantee.  &quot;Have
a good time, all the time&quot;, that's our motto.</p>
<p>Within the lower levels of the Template Toolkit, there are lots of messy
details that we generally don't want to have to worry about most of the time.
Things like templates not being found, or failing to parse correctly, uncaught
exceptions being thrown, missing plugin modules or dependencies, and so on.
<a href="../../../..//Develop/Perl/Template-Toolkit-2.24/blib/html/site/lib/Template/Service.html">the Template::Service manpage</a> hides that all away and makes everything look simple to
the outsider. It provides extra features, like <code>PRE_PROCESS</code>, <code>PROCESS</code> and
<code>POST_PROCESS</code>, and also provides the error recovery mechanism via <code>ERROR</code>.
You ask it to process a template and it takes care of everything for you. The
<code>Template::Service::Apache</code> module goes a little bit further, adding some extra
headers to the <a href="../../../../Apache/Request.html">the Apache::Request manpage</a>, setting a few extra template variables, and so
on.</p>
<p>For the most part, the job of a service is really just one of scheduling and
dispatching. It receives a request in the form of a call to its
<a href="../../../../Template/Service#process().html">process()</a> method and schedules the named
template specified as an argument, and possibly several other templates
(<code>PRE_PROCESS</code>, etc) to be processed in order. It doesn't actually process
the templates itself, but instead makes a
<a href="../../../../Template/Context#process().html">process()</a> call against a <a href="../../../..//Develop/Perl/Template-Toolkit-2.24/blib/html/site/lib/Template/Context.html">the Template::Context manpage</a>
object.</p>
<p><a href="../../../..//Develop/Perl/Template-Toolkit-2.24/blib/html/site/lib/Template/Context.html">the Template::Context manpage</a> is the runtime engine for the Template Toolkit -
the module that hangs everything together in the lower levels of the
Template Toolkit and that one that does most of the real work, albeit
by crafty delegation to various other friendly helper modules.</p>
<p>Given a template name (or perhaps a reference to a scalar or file
handle) the context <code>process()</code> method must load and compile, or fetch a
cached copy of a previously compiled template, corresponding to that
name.  It does this by calling on a list of one or more
<a href="../../../..//Develop/Perl/Template-Toolkit-2.24/blib/html/site/lib/Template/Provider.html">the Template::Provider manpage</a> objects (the <code>LOAD_TEMPLATES</code> posse) who themselves
might get involved with a <a href="../../../..//Develop/Perl/Template-Toolkit-2.24/blib/html/site/lib/Template/Parser.html">the Template::Parser manpage</a> to help turn source
templates into executable Perl code (but more on that later).</p>
<p>Thankfully, all of this complexity is hidden away behind a simple
<a href="../../../../Template/Context#template().html">template()</a> method. You call it passing a
template name as an argument, and it returns a compiled template in the form
of a <a href="../../../..//Develop/Perl/Template-Toolkit-2.24/blib/html/site/lib/Template/Document.html">the Template::Document manpage</a> object, or otherwise raises an exception.</p>
<p>A <a href="../../../..//Develop/Perl/Template-Toolkit-2.24/blib/html/site/lib/Template/Document.html">the Template::Document manpage</a> is a thin object wrapper around a compiled template
subroutine. The object implements a <a href="../../../../Template/Document#process().html">process()</a>
method which performs a little bit of housekeeping and then calls the template
subroutine. The object also defines template metadata (defined in <code>[% META
... %]</code> directives) and has a <a href="../../../../Template/Document#block().html">block()</a> method
which returns a hash of any additional <code>[% BLOCK xxxx %]</code> definitions found
in the template source.</p>
<p>So the context fetches a compiled document via its own
<a href="../../../../Template/Context#template().html">template()</a> method and then gets ready to
process it. It first updates the stash (the place where template variables get
defined - more on that shortly) to set any template variable definitions
specified as the second argument by reference to hash array. Then, it calls
the document <a href="../../../../Template/Document#process().html">process()</a> method, passing a
reference to itself, the context object, as an argument. In doing this, it
provides itself as an object against which template code can make callbacks to
access runtime resources and Template Toolkit functionality.</p>
<p>What we're trying to say here is this:  not only does the <a href="../../../..//Develop/Perl/Template-Toolkit-2.24/blib/html/site/lib/Template/Context.html">the Template::Context manpage</a>
object receive calls from the <em>outside</em>, i.e. those originating in user
code calling the <code>process()</code> method on a Template object, but it also 
receives calls from the <em>inside</em>, i.e. those originating in template
directives of the form <code>[% PROCESS template %]</code>.</p>
<p>Before we move on to that, here's a simple structure diagram showing
the outer layers of the Template Toolkit heading inwards, with pseudo
code annotations showing a typical invocation sequence.</p>
<pre>
     <span class="operator">,--------.</span>
     <span class="operator">|</span> <span class="variable">Caller</span> <span class="operator">|</span>     <span class="keyword">use</span> <span class="variable">Template</span><span class="operator">;</span>
     <span class="string">`--------'     my </span><span class="variable">$tt</span><span class="string"> = Template-&gt;new( ... );
          |         </span><span class="variable">$tt</span><span class="string">-&gt;process(</span><span class="variable">$template</span><span class="string">, \%vars);
          |                                                     Outside
         - - - | - - - - - - - - - - - - - - - - - - - - - - - - - - - - T T 
          |         package Template;                            Inside
          V
         +----------+    sub process(</span><span class="variable">$template</span><span class="string">, \%vars) {
         | Template |        </span><span class="variable">$out</span><span class="string"> = </span><span class="variable">$self</span><span class="string">-&gt;SERVICE-&gt;process(</span><span class="variable">$template</span><span class="string">, </span><span class="variable">$vars</span><span class="string">);
         +----------+        print </span><span class="variable">$out</span><span class="string"> or send it to </span><span class="variable">$self</span><span class="string">-&gt;OUTPUT;
          |         }
          |
          |         package Template::Service;
          |
          |         sub process(</span><span class="variable">$template</span><span class="string">, \%vars) {
          |             try {
         +----------+            foreach </span><span class="variable">$p</span><span class="string"> in </span><span class="variable">@self</span><span class="string">-&gt;PRE_PROCESS
         | Service  |                </span><span class="variable">$self</span><span class="string">-&gt;CONTEXT-&gt;process(</span><span class="variable">$p</span><span class="string">, </span><span class="variable">$vars</span><span class="string">);
         +----------+
          |                 </span><span class="variable">$self</span><span class="string">-&gt;CONTEXT-&gt;process(</span><span class="variable">$template</span><span class="string">, </span><span class="variable">$vars</span><span class="string">);
          |
          |                 foreach </span><span class="variable">$p</span><span class="string"> </span><span class="variable">@self</span><span class="string">-&gt;POST_PROCESS
          |                     </span><span class="variable">$self</span><span class="string">-&gt;CONTEXT-&gt;process(</span><span class="variable">$p</span><span class="string">, </span><span class="variable">$vars</span><span class="string">);
          |             }
          |             catch {
          |                 </span><span class="variable">$self</span><span class="string">-&gt;CONTEXT-&gt;process(</span><span class="variable">$self</span><span class="string">-&gt;ERROR);
          |             }
          |         }
          |
          V         package Template::Context;
         +----------+    
         | Context  |    sub process(</span><span class="variable">$template</span><span class="string">, \%vars) {
         +----------+        # fetch compiled template
          |             </span><span class="variable">$template</span><span class="string"> = </span><span class="variable">$self</span><span class="string">-&gt;template(</span><span class="variable">$template</span><span class="string">)
          |             # update stash
          |             </span><span class="variable">$self</span><span class="string">-&gt;STASH-&gt;update(</span><span class="variable">$vars</span><span class="string">);
          |             # process template
          |             </span><span class="variable">$template</span><span class="string">-&gt;process(</span><span class="variable">$self</span><span class="string">)
          |         }
          V     
         +----------+    package Template::Document;
         | Document |    
         +----------+    sub process(</span><span class="variable">$context</span><span class="string">) {
                        </span><span class="variable">$output</span><span class="string"> = &amp;{ </span><span class="variable">$self</span><span class="string">-&gt;BLOCK }(</span><span class="variable">$context</span><span class="string">);
                    }
     </span>
</pre>
<p>
</p>
<hr />
<h1><a name="inside_looking_out">Inside Looking Out</a></h1>
<p>To understand more about what's going on in these lower levels, we
need to look at what a compiled template looks like.  In fact, a
compiled template is just a regular Perl sub-routine.  Here's a very
simple one.</p>
<pre>
    <span class="keyword">sub</span><span class="variable"> my_compiled_template </span><span class="operator">{</span>
        <span class="keyword">return</span> <span class="string">"This is a compiled template.\n"</span><span class="operator">;</span>
    <span class="operator">}</span>
</pre>
<p>You're unlikely to see a compiled template this simple unless you
wrote it yourself but it is entirely valid.  All a template subroutine
is obliged to do is return some output (which may be an empty of
course).  If it can't for some reason, then it should raise an error
via <a href="../../../../lib/pods/perlfunc.html#die"><code>die()</code></a>.</p>
<pre>
    <span class="keyword">sub</span><span class="variable"> my_todo_template </span><span class="operator">{</span>
        <span class="keyword">die</span> <span class="string">"This template not yet implemented\n"</span><span class="operator">;</span>
    <span class="operator">}</span>
</pre>
<p>If it wants to get fancy, it can raise an error as a
<a href="../../../..//Develop/Perl/Template-Toolkit-2.24/blib/html/site/lib/Template/Exception.html">the Template::Exception manpage</a> object.  An exception object is really just a
convenient wrapper for the '<code>type</code>' and '<code>info</code>' fields.</p>
<pre>
    <span class="keyword">sub</span><span class="variable"> my_solilique_template </span><span class="operator">{</span>
        <span class="keyword">die</span> <span class="operator">(</span><span class="variable">Template::Exception</span><span class="operator">-&gt;</span><span class="variable">new</span><span class="operator">(</span><span class="string">'yorrick'</span><span class="operator">,</span> <span class="string">'Fellow of infinite jest'</span><span class="operator">));</span>
    <span class="operator">}</span>
</pre>
<p>Templates generally need to do a lot more than just generate static output or
raise errors. They may want to inspect variable values, process another
template, load a plugin, run a filter, and so on. Whenever a template
subroutine is called, it gets passed a reference to a <a href="../../../..//Develop/Perl/Template-Toolkit-2.24/blib/html/site/lib/Template/Context.html">the Template::Context manpage</a>
object. It is through this context object that template code can access the
features of the Template Toolkit.</p>
<p>We described earlier how the <a href="../../../..//Develop/Perl/Template-Toolkit-2.24/blib/html/site/lib/Template/Service.html">the Template::Service manpage</a> object calls on
<a href="../../../..//Develop/Perl/Template-Toolkit-2.24/blib/html/site/lib/Template/Context.html">the Template::Context manpage</a> to handle a <a href="../../../../Template/Context#process().html">process()</a>
request from the <em>outside</em>. We can make a similar request on a context to
process a template, but from within the code of another template. This is a
call from the <em>inside</em>.</p>
<pre>
    <span class="keyword">sub</span><span class="variable"> my_process_template </span><span class="operator">{</span>
        <span class="keyword">my</span> <span class="variable">$context</span> <span class="operator">=</span> <span class="keyword">shift</span><span class="operator">;</span>
        <span class="keyword">my</span> <span class="variable">$output</span> <span class="operator">=</span> <span class="variable">$context</span><span class="operator">-&gt;</span><span class="variable">process</span><span class="operator">(</span><span class="string">'header'</span><span class="operator">,</span> <span class="operator">{</span> <span class="string">title</span> <span class="operator">=&gt;</span> <span class="string">'Hello World'</span> <span class="operator">}</span><span class="operator">)</span>
                   <span class="operator">.</span> <span class="string">"\nsome content\n"</span>
                   <span class="operator">.</span> <span class="variable">$context</span><span class="operator">-&gt;</span><span class="variable">process</span><span class="operator">(</span><span class="string">'footer'</span><span class="operator">);</span>
    <span class="operator">}</span>
</pre>
<p>This is then roughly equivalent to a source template something
like this:</p>
<pre>
    [% PROCESS header
        title = 'Hello World'
    %]
    some content
    [% PROCESS footer %]</pre>
<p>Template variables are stored in, and managed by a <a href="../../../..//Develop/Perl/Template-Toolkit-2.24/blib/html/site/lib/Template/Stash.html">the Template::Stash manpage</a> object.
This is a blessed hash array in which template variables are defined. The
object wrapper provides <a href="../../../../Template/Stash#get().html">get()</a> and
<a href="../../../../Template/Stash#set().html">set()</a> method which implement all the
<em>magical.variable.features</em> of the Template Toolkit.</p>
<p>Each context object has its own stash, a reference to which can be returned by
the appropriately named <a href="../../../../Template/Context#stash().html">stash()</a> method. So to
print the value of some template variable, or for example, to represent the
following source template:</p>
<pre>
    &lt;title&gt;[% title %]&lt;/title&gt;</pre>
<p>we might have a subroutine definition something like this:</p>
<pre>
    <span class="keyword">sub</span><span class="variable"> </span><span class="operator">{</span>
        <span class="keyword">my</span> <span class="variable">$context</span> <span class="operator">=</span> <span class="keyword">shift</span><span class="operator">;</span>
        <span class="keyword">my</span> <span class="variable">$stash</span> <span class="operator">=</span> <span class="variable">$context</span><span class="operator">-&gt;</span><span class="variable">stash</span><span class="operator">();</span>
        <span class="keyword">return</span> <span class="string">'&lt;title&gt;'</span> <span class="operator">.</span> <span class="variable">$stash</span><span class="operator">-&gt;</span><span class="variable">get</span><span class="operator">(</span><span class="string">'title'</span><span class="operator">)</span> <span class="operator">.</span> <span class="string">'&lt;/title&gt;'</span><span class="operator">;</span>
    <span class="operator">}</span>
</pre>
<p>The stash <a href="../../../../Template/Stash#get().html">get()</a> method hides the details of the
underlying variable types, automatically calling code references, checking
return values, and performing other such tricks. If '<code>title</code>' happens to be
bound to a subroutine then we can specify additional parameters as a list
reference passed as the second argument to <code>get()</code>.</p>
<pre>
    [% title('The Cat Sat on the Mat') %]</pre>
<p>This translates to the stash call:</p>
<pre>
    <span class="variable">$stash</span><span class="operator">-&gt;</span><span class="variable">get</span><span class="operator">(</span><span class="operator">[</span> <span class="string">'title'</span><span class="operator">,</span> <span class="operator">[</span><span class="string">'The Cat Sat on the Mat'</span><span class="operator">]</span> <span class="operator">]</span><span class="operator">);</span>
</pre>
<p>Dotted compound variables can be requested by passing a single 
list reference to the <code>get()</code> method in place of the variable 
name.  Each pair of elements in the list should correspond to the
variable name and reference to a list of arguments for each 
dot-delimited element of the variable.</p>
<pre>
    [% foo(1, 2).bar(3, 4).baz(5) %]</pre>
<p>is thus equivalent to</p>
<pre>
    <span class="variable">$stash</span><span class="operator">-&gt;</span><span class="variable">get</span><span class="operator">(</span><span class="operator">[</span> <span class="string">foo</span> <span class="operator">=&gt;</span> <span class="operator">[</span><span class="number">1</span><span class="operator">,</span><span class="number">2</span><span class="operator">]</span><span class="operator">,</span> <span class="string">bar</span> <span class="operator">=&gt;</span> <span class="operator">[</span><span class="number">3</span><span class="operator">,</span><span class="number">4</span><span class="operator">]</span><span class="operator">,</span> <span class="string">baz</span> <span class="operator">=&gt;</span> <span class="operator">[</span><span class="number">5</span><span class="operator">]</span> <span class="operator">]</span><span class="operator">);</span>
</pre>
<p>If there aren't any arguments for an element, you can specify an 
empty, zero or null argument list.</p>
<pre>
    <span class="operator">[</span><span class="operator">% </span><span class="variable">foo</span><span class="operator">.</span><span class="variable">bar</span> <span class="variable">%]</span>
    <span class="variable">$stash</span><span class="operator">-&gt;</span><span class="variable">get</span><span class="operator">(</span><span class="operator">[</span> <span class="string">'foo'</span><span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="string">'bar'</span><span class="operator">,</span> <span class="number">0</span> <span class="operator">]</span><span class="operator">);</span>
</pre>
<p>The <a href="../../../../Template/Stash#set().html">set()</a> method works in a similar way. It takes a
variable name and a variable value which should be assigned to it.</p>
<pre>
    <span class="operator">[</span><span class="operator">% x</span> <span class="operator">=</span> <span class="number">10</span> <span class="variable">%]</span>         
    <span class="variable">$stash</span><span class="operator">-&gt;</span><span class="variable">set</span><span class="operator">(</span><span class="string">'x'</span><span class="operator">,</span> <span class="number">10</span><span class="operator">);</span>
    
    <span class="operator">[</span><span class="operator">% x.</span><span class="regex">y = 10 %]
    </span><span class="variable">$stash</span><span class="regex">-&gt;set([ 'x', 0, 'y', 0 ], 10);
    </span>
</pre>
<p>So the stash gives us access to template variables and the context provides
the higher level functionality.</p>
<p>Alongside the <a href="../../../../Template/Context#process().html">process()</a> method lies the
<a href="../../../../Template/Context#include().html">include()</a> method. Just as with the <code>PROCESS</code> /
<code>INCLUDE</code> directives, the key difference is in variable localisation. Before
processing a template, the <code>process()</code> method simply updates the stash to set
any new variable definitions, overwriting any existing values. In contrast,
the <code>include()</code> method creates a copy of the existing stash, in a process known
as <em>cloning</em> the stash, and then uses that as a temporary variable store. Any
previously existing variables are still defined, but any changes made to
variables, including setting the new variable values passed aas arguments will
affect only the local copy of the stash (although note that it's only a
shallow copy, so it's not foolproof). When the template has been processed,
the <code>include()</code> method restores the previous variable state by <em>decloning</em> the
stash.</p>
<p>The context also provides an <a href="../../../../Template/Context#insert().html">insert()</a> method to
implement the <code>INSERT</code> directive, but no <code>wrapper()</code> method. This functionality
can be implemented by rewriting the Perl code and calling <code>include()</code>.</p>
<pre>
    <span class="operator">[</span><span class="operator">% </span><span class="variable">WRAPPER</span> <span class="variable">foo</span> <span class="operator">-</span><span class="variable">%]</span>
       <span class="variable">blah</span> <span class="variable">blah</span> <span class="operator">[</span><span class="operator">% x</span> <span class="variable">%]</span>
    <span class="operator">[</span><span class="variable">%-</span> <span class="keyword">END</span> <span class="variable">%]</span>
    
    <span class="variable">$context</span><span class="operator">-&gt;</span><span class="variable">include</span><span class="operator">(</span><span class="string">'foo'</span><span class="operator">,</span> <span class="operator">{</span>
        <span class="string">content</span> <span class="operator">=&gt;</span> <span class="string">'blah blah '</span> <span class="operator">.</span> <span class="variable">$stash</span><span class="operator">-&gt;</span><span class="variable">get</span><span class="operator">(</span><span class="string">'x'</span><span class="operator">),</span>
    <span class="operator">}</span><span class="operator">);</span>
</pre>
<p>Other than the template processing methods <code>process()</code>, <code>include()</code> and
<code>insert()</code>, the context defines methods for fetching plugin objects,
<a href="../../../../Template/Context#plugin().html">plugin()</a>, and filters,
<a href="../../../../Template/Context#filter().html">filter()</a>.</p>
<pre>
    <span class="comment"># TT USE directive</span>
    <span class="operator">[</span><span class="operator">% </span><span class="variable">USE</span> <span class="variable">foo</span> <span class="operator">=</span> <span class="variable">Bar</span><span class="operator">(</span><span class="number">10</span><span class="operator">)</span> <span class="variable">%]</span>
    
    <span class="comment"># equivalent Perl</span>
    <span class="variable">$stash</span><span class="operator">-&gt;</span><span class="variable">set</span><span class="operator">(</span><span class="string">'foo'</span><span class="operator">,</span> <span class="variable">$context</span><span class="operator">-&gt;</span><span class="variable">plugin</span><span class="operator">(</span><span class="string">'Bar'</span><span class="operator">,</span> <span class="operator">[</span><span class="number">10</span><span class="operator">]</span><span class="operator">));</span>
</pre>
<pre>
    <span class="comment"># TT FILTER block</span>
    <span class="operator">[</span><span class="operator">% </span><span class="variable">FILTER</span> <span class="variable">bar</span><span class="operator">(</span><span class="number">20</span><span class="operator">)</span> <span class="variable">%]</span>
       <span class="variable">blah</span> <span class="variable">blah</span> <span class="variable">blah</span>
    <span class="operator">[</span><span class="operator">% </span><span class="keyword">END</span> <span class="variable">%]</span>
    
    <span class="comment"># equivalent Perl</span>
    <span class="keyword">my</span> <span class="variable">$filter</span> <span class="operator">=</span> <span class="variable">$context</span><span class="operator">-&gt;</span><span class="variable">filter</span><span class="operator">(</span><span class="string">'bar'</span><span class="operator">,</span> <span class="operator">[</span><span class="number">20</span><span class="operator">]</span><span class="operator">);</span>
    <span class="operator">&amp;</span><span class="variable">$filter</span><span class="operator">(</span><span class="string">'blah blah blah'</span><span class="operator">);</span>
</pre>
<p>Pretty much everything else you might want to do in a template can be done in
Perl code. Things like <code>IF</code>, <code>UNLESS</code>, <code>FOREACH</code> and so on all have direct
counterparts in Perl.</p>
<pre>
    <span class="comment"># TT IF directive</span>
    <span class="operator">[</span><span class="operator">% </span><span class="variable">IF</span> <span class="variable">msg</span> <span class="variable">%]</span>
       <span class="variable">Message</span><span class="operator">:</span> <span class="operator">[</span><span class="operator">% </span><span class="variable">msg</span> <span class="variable">%]</span>
    <span class="operator">[</span><span class="operator">% </span><span class="keyword">END</span> <span class="variable">%]</span><span class="operator">;</span>
</pre>
<pre>
    <span class="comment"># equivalent Perl</span>
    <span class="keyword">if</span> <span class="operator">(</span><span class="variable">$stash</span><span class="operator">-&gt;</span><span class="variable">get</span><span class="operator">(</span><span class="string">'msg'</span><span class="operator">))</span> <span class="operator">{</span>
        <span class="variable">$output</span> <span class="operator">.=</span>  <span class="string">'Message: '</span><span class="operator">;</span>
        <span class="variable">$output</span> <span class="operator">.=</span> <span class="variable">$stash</span><span class="operator">-&gt;</span><span class="variable">get</span><span class="operator">(</span><span class="string">'msg'</span><span class="operator">);</span>
    <span class="operator">}</span>
</pre>
<p>The best way to get a better understanding of what's going on underneath
the hood is to set the <code>$Template::Parser::DEBUG</code> flag to a true value
and start processing templates.  This will cause the parser to print the
generated Perl code for each template it compiles to <code>STDERR</code>.  You'll 
probably also want to set the <code>$Template::Directive::PRETTY</code> option to
have the Perl pretty-printed for human consumption.</p>
<pre>
    <span class="keyword">use</span> <span class="variable">Template</span><span class="operator">;</span>
    <span class="keyword">use</span> <span class="variable">Template::Parser</span><span class="operator">;</span>
    <span class="keyword">use</span> <span class="variable">Template::Directive</span><span class="operator">;</span>
    
    <span class="variable">$Template::Parser::DEBUG</span> <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
    <span class="variable">$Template::Directive::PRETTY</span> <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
    
    <span class="keyword">my</span> <span class="variable">$template</span> <span class="operator">=</span> <span class="variable">Template</span><span class="operator">-&gt;</span><span class="variable">new</span><span class="operator">();</span>
    <span class="variable">$template</span><span class="operator">-&gt;</span><span class="variable">process</span><span class="operator">(\</span><span class="variable">*DATA</span><span class="operator">,</span> <span class="operator">{</span> <span class="string">cat</span> <span class="operator">=&gt;</span> <span class="string">'dog'</span><span class="operator">,</span> <span class="string">mat</span> <span class="operator">=&gt;</span> <span class="string">'log'</span> <span class="operator">}</span><span class="operator">);</span>
    
    <span class="comment">__DATA__
    The [% cat %] sat on the [% mat %]
    </span>
</pre>
<p>The output sent to <code>STDOUT</code> remains as you would expect:</p>
<pre>
    The dog sat on the log</pre>
<p>The output sent to <code>STDERR</code> would look something like this:</p>
<pre>
    <span class="variable">compiled</span> <span class="variable">main</span> <span class="variable">template</span> <span class="variable">document</span> <span class="variable">block</span><span class="operator">:</span>
    <span class="keyword">sub</span><span class="variable"> </span><span class="operator">{</span>
        <span class="keyword">my</span> <span class="variable">$context</span> <span class="operator">=</span> <span class="keyword">shift</span> <span class="operator">||</span> <span class="keyword">die</span> <span class="string">"template sub called without context\n"</span><span class="operator">;</span>
        <span class="keyword">my</span> <span class="variable">$stash</span>   <span class="operator">=</span> <span class="variable">$context</span><span class="operator">-&gt;</span><span class="variable">stash</span><span class="operator">;</span>
        <span class="keyword">my</span> <span class="variable">$output</span>  <span class="operator">=</span> <span class="string">''</span><span class="operator">;</span>
        <span class="keyword">my</span> <span class="variable">$error</span><span class="operator">;</span>
        
        <span class="keyword">eval</span> <span class="operator">{</span> <span class="variable">BLOCK</span><span class="operator">:</span> <span class="operator">{</span>
            <span class="variable">$output</span> <span class="operator">.=</span>  <span class="string">"The "</span><span class="operator">;</span>
            <span class="variable">$output</span> <span class="operator">.=</span>  <span class="variable">$stash</span><span class="operator">-&gt;</span><span class="variable">get</span><span class="operator">(</span><span class="string">'cat'</span><span class="operator">);</span>
            <span class="variable">$output</span> <span class="operator">.=</span>  <span class="string">" sat on the "</span><span class="operator">;</span>
            <span class="variable">$output</span> <span class="operator">.=</span>  <span class="variable">$stash</span><span class="operator">-&gt;</span><span class="variable">get</span><span class="operator">(</span><span class="string">'mat'</span><span class="operator">);</span>
            <span class="variable">$output</span> <span class="operator">.=</span>  <span class="string">"\n"</span><span class="operator">;</span>
        <span class="operator">}</span> <span class="operator">};</span>
        <span class="keyword">if</span> <span class="operator">(</span><span class="variable">$@</span><span class="operator">)</span> <span class="operator">{</span>
            <span class="variable">$error</span> <span class="operator">=</span> <span class="variable">$context</span><span class="operator">-&gt;</span><span class="variable">catch</span><span class="operator">(</span><span class="variable">$@</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">$output</span><span class="operator">);</span>
            <span class="keyword">die</span> <span class="variable">$error</span> <span class="keyword">unless</span> <span class="variable">$error</span><span class="operator">-&gt;</span><span class="variable">type</span> <span class="keyword">eq</span> <span class="string">'return'</span><span class="operator">;</span>
        <span class="operator">}</span>
    
        <span class="keyword">return</span> <span class="variable">$output</span><span class="operator">;</span>
    <span class="operator">}</span>
</pre>
<p>
</p>
<hr />
<h1><a name="hacking_on_the_template_toolkit">Hacking on the Template Toolkit</a></h1>
<p>Please feel free to hack on the Template Toolkit.  If you find a bug
that needs fixing, if you have an idea for something that's missing,
or you feel inclined to tackle something on the TODO list, then by all
means go ahead and do it!</p>
<p>If you're contemplating something non-trivial then you'll probably
want to bring it up on the mailing list first to get an idea about the
current state of play, find out if anyone's already working on it, and
so on.</p>
<p>When you start to hack on the Template Toolkit, please make sure you
start from the latest developer release.  Stable releases are uploaded
to CPAN and have all-numerical version numbers, e.g. 2.04, 2.05. 
Developer releases are available from the Template Toolkit web site
and have a character suffix on the version, e.g. 2.04a, 2.04b, etc.</p>
<p>Once you've made your changes, please remember to update the test 
suite by adding extra tests to one of the existing test scripts in
the <a href="../../../../lib/pods/perlrun.html#t"><code>t</code></a> sub-directory, or by adding a new test script of your own.
And of course, run <code>make test</code> to ensure that all the tests pass
with your new code.</p>
<p>Don't forget that any files you do add will need to be added to the
MANIFEST.  Running <code>make manifest</code> will do this for you, but you need
to make sure you haven't got any other temporary files lying around 
that might also get added to it.</p>
<p>Documentation is often something that gets overlooked but it's just as
important as the code. If you're adding a new module, a plugin module, for
example, then it's OK to include the POD documentation in with the module, but
<em>please</em> write it all in one piece at the end of the file, <em>after</em> the code
(just look at any other <code>Template::*</code> module for an example). It's a
religious issue, I know, but I have a strong distaste for POD documentation
interspersed throughout the code. In my not-so-humble opinion, it makes both
the code and the documentation harder to read (same kinda problem as embedding
Perl in HTML).</p>
<p>To share your changes with the rest of the world, you'll need to 
prepare a patch file.  To do this you should have 2 directories
side-by-side, one which is the original, unmodified distribution
directory for the latest developer release, and the other is a
copy of that same directory which includes your changes.</p>
<p>The following example shows a typical hacking session.  First we
unpack the latest developer release.</p>
<pre>
    $ tar zxf Template-Toolkit-2.05c.tar.gz</pre>
<p>At this point, it's a good idea to rename the directory to give 
some indicate of what it contains.</p>
<pre>
    $ mv Template-Toolkit-2.05c Template-Toolkit-2.05c-abw-xyz-hack</pre>
<p>Then go hack!</p>
<pre>
    $ cd Template-Toolkit-2.05c-abw-xyz-hack</pre>
<pre>
      [ hacking ]</pre>
<pre>
    $ cd ..</pre>
<p>When you're all done and ready to prepare a patch, unpack the 
distribution archive again so that you've got the original to 
<code>diff</code> against your new code.</p>
<pre>
    $ tar zxf Template-Toolkit-2.05c.tar.gz</pre>
<p>You should now have an original distribution directory and a modified
version of that same directory, side-by-side.</p>
<pre>
    $ ls
    Template-Toolkit-2.05c  Template-Toolkit-2.05c-abw-xyz-hack</pre>
<p>Now run <code>diff</code> and save the output into an appropriately named patch
file.</p>
<pre>
    $ diff -Naur Template-Toolkit-2.05c Template-Toolkit-2.05c-abw-xyz-hack &gt; patch-TT205c-abw-xyz-hack</pre>
<p>You can then post the generated patch file to the mailing list, 
describing what it does, why it does it, how it does it and any 
other relevant information.</p>
<p>If you want to apply someone else's patch then you should start with the
same original distribution source on which the patch is based.  From within
the root of the distribution, run <code>patch</code> feeding in the patch file as 
standard input.  The '<code>p1</code>' option is required to strip the first element
of the path name (e.g. <code>Template-Toolkit-2.05c/README</code> becomes <code>README</code> which
is then the correct path).</p>
<pre>
    $ tar zxf Template-Toolkit-2.05c.tar.gz
    $ cd Template-Toolkit-2.05c
    $ patch -p1 &lt; ../patch-TT205c-abw-xyz-hack</pre>
<p>The output generated by <code>patch</code> should be something like the following:</p>
<pre>
    patching file README
    patching file lib/Template.pm
    patching file lib/Template/Provider.pm
    patching file t/provider.t</pre>

</body>

</html>
